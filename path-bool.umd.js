var t,n;t=this,n=function(t){const n=0,e=1,o=2,r=4,i=8;function s(t,s,a){let c=n;return t<a.left?c|=e:t>a.right&&(c|=o),s<a.top?c|=r:s>a.bottom&&(c|=i),c}function a(t,n){let[[a,c],[u,f]]=t,l=s(a,c,n),d=s(u,f,n);for(;;){if(!(l|d))return!0;if(l&d)return!1;{const{top:t,right:g,bottom:h,left:p}=n;let m,b;const M=d>l?d:l;M&i?(m=a+(u-a)*(h-c)/(f-c),b=h):M&r?(m=a+(u-a)*(t-c)/(f-c),b=t):M&o?(b=c+(f-c)*(g-a)/(u-a),m=g):M&e&&(b=c+(f-c)*(p-a)/(u-a),m=p),M==l?(a=m,c=b,l=s(a,c,n)):(u=m,f=b,d=s(u,f,n))}}}function c(t,n){return t.left<=n.right&&n.left<=t.right&&t.top<=n.bottom&&n.top<=t.bottom}function u(t,n){return t?{top:Math.min(t.top,n.top),right:Math.max(t.right,n.right),bottom:Math.max(t.bottom,n.bottom),left:Math.min(t.left,n.left)}:n}function f(t,n){return t?{top:Math.min(t.top,n[1]),right:Math.max(t.right,n[0]),bottom:Math.max(t.bottom,n[1]),left:Math.min(t.left,n[0])}:{top:n[1],right:n[0],bottom:n[1],left:n[0]}}function l(t){return Math.max(t.right-t.left,t.bottom-t.top)}function d(t,n){return{top:t[1]-n,right:t[0]+n,bottom:t[1]+n,left:t[0]-n}}class g{static fromPairs(t,n,e=8){if(0===t.length)throw new Error("QuadTree.fromPairs: at least one pair needed.");let o=t[0][0];for(let n=1;n<t.length;n++)o=u(o,t[n][0]);const r=new g(o,n,e);for(const[n,e]of t)r.insert(n,e);return r}constructor(t,n,e=16){this.boundingBox=t,this.depth=n,this.innerNodeCapacity=e,this.subtrees=null,this.pairs=[]}insert(t,n){if(!c(t,this.boundingBox))return!1;if(this.depth>0&&this.pairs.length>=this.innerNodeCapacity){this.ensureSubtrees();for(let e=0;e<this.subtrees.length;e++)this.subtrees[e].insert(t,n)}else this.pairs.push([t,n]);return!0}find(t,n=new Set){if(!c(t,this.boundingBox))return n;for(let e=0;e<this.pairs.length;e++){const[o,r]=this.pairs[e];c(t,o)&&n.add(r)}if(this.subtrees)for(let e=0;e<this.subtrees.length;e++)this.subtrees[e].find(t,n);return n}findOnLineSegment(t,n=new Set){if(!a(t,this.boundingBox))return n;for(const[e,o]of this.pairs)a(t,e)&&n.add(o);if(this.subtrees)for(const e of this.subtrees)e.findOnLineSegment(t,n);return n}ensureSubtrees(){if(this.subtrees)return;const{top:t,right:n,bottom:e,left:o}=this.boundingBox,r=(this.boundingBox.left+this.boundingBox.right)/2,i=(this.boundingBox.top+this.boundingBox.bottom)/2;this.subtrees=[new g({top:t,right:r,bottom:i,left:o},this.depth-1,this.innerNodeCapacity),new g({top:t,right:n,bottom:i,left:r},this.depth-1,this.innerNodeCapacity),new g({top:i,right:r,bottom:e,left:o},this.depth-1,this.innerNodeCapacity),new g({top:i,right:n,bottom:e,left:r},this.depth-1,this.innerNodeCapacity)]}}const h=1e-12;function p(t){const n=t[1],e=t[2],o=t[3],r=t[4],i=-n[0]+3*e[0]-3*o[0]+r[0],s=-n[1]+3*e[1]-3*o[1]+r[1],a=3*n[0]-6*e[0]+3*o[0],c=3*n[1]-6*e[1]+3*o[1],u=-3*n[0]+3*e[0],f=-3*n[1]+3*e[1],l=s*a-i*c,d=i*f-s*u,g=(-3*i*i*f*f+6*i*s*u*f+4*i*a*c*f-4*i*c*c*u-3*s*s*u*u-4*s*a*a*f+4*s*a*c*u)/(i*i*c*c-2*i*s*a*c+s*s*a*a);if(g<0)return null;const p=(d/l+Math.sqrt(g))/2,m=(d/l-Math.sqrt(g))/2;return h<=p&&p<=1-h&&h<=m&&m<=1-h?[p,m]:null}var m="undefined"!=typeof Float32Array?Float32Array:Array;function b(){var t=new m(4);return m!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t}function M(t,n){var e=Math.sin(n),o=Math.cos(n);return t[0]=o,t[1]=e,t[2]=-e,t[3]=o,t}function y(){var t=new m(6);return m!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t}function x(t,n){var e=Math.sin(n),o=Math.cos(n);return t[0]=o,t[1]=e,t[2]=-e,t[3]=o,t[4]=0,t[5]=0,t}Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var w=function(t,n,e){var o=n[0],r=n[1],i=n[2],s=n[3],a=n[4],c=n[5],u=e[0],f=e[1],l=e[2],d=e[3],g=e[4],h=e[5];return t[0]=o*u+i*f,t[1]=r*u+s*f,t[2]=o*l+i*d,t[3]=r*l+s*d,t[4]=o*g+i*h+a,t[5]=r*g+s*h+c,t};function F(t,n,e){return t[0]=n,t[1]=e,t}function B(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t}function k(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t}function E(t,n){var e=n[0],o=n[1],r=e*e+o*o;return r>0&&(r=1/Math.sqrt(r)),t[0]=n[0]*r,t[1]=n[1]*r,t}function v(t,n){return t[0]*n[0]+t[1]*n[1]}function P(t,n,e,o){var r=n[0],i=n[1];return t[0]=r+o*(e[0]-r),t[1]=i+o*(e[1]-i),t}function A(t,n,e){var o=n[0],r=n[1];return t[0]=e[0]*o+e[2]*r,t[1]=e[1]*o+e[3]*r,t}function L(t,n,e){var o=n[0],r=n[1];return t[0]=e[0]*o+e[2]*r+e[4],t[1]=e[1]*o+e[3]*r+e[5],t}var C,I=function(t){var n=t[0],e=t[1];return Math.hypot(n,e)},V=function(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t},S=function(t){var n=t[0],e=t[1];return n*n+e*e};C=new m(2),m!=Float32Array&&(C[0]=0,C[1]=0);const Q=2*Math.PI;function T(t,n,e){return t+(n-t)*e}function O(t){return t/180*Math.PI}function q(t,n){const e=Math.sign(t[0]*n[1]-t[1]*n[0]);return 0===e&&Math.abs(t[0]+n[0])<1e-12&&Math.abs(t[1]+n[1])<1e-12?Math.PI:e*Math.acos(v(t,n)/I(t)/I(n))}function N(t,n,e=0){return Math.abs(t[0]-n[0])<=e&&Math.abs(t[1]-n[1])<=e}function $(t){return t[1]}function D(t){switch(t[0]){case"L":return t[2];case"C":return t[4];case"Q":return t[3];case"A":return t[7]}}function W(t){switch(t[0]){case"L":return["L",t[2],t[1]];case"C":return["C",t[4],t[3],t[2],t[1]];case"Q":return["Q",t[3],t[2],t[1]];case"A":return["A",t[7],t[2],t[3],t[4],t[5],!t[6],t[1]]}}const Z=(()=>{const t=[0,0],n=b(),e=[0,0],o=[0,0];return function([r,i,s,a,c,u,f,l]){if(0===s||0===a)return null;M(n,-O(c)),V(t,i,l),k(t,t,.5),A(t,t,n);let d=s*s,g=a*a;const h=t[0]*t[0],p=t[1]*t[1];s=Math.abs(s),a=Math.abs(a);const m=h/d+p/g+1e-12;if(m>1){const t=Math.sqrt(m);s*=t,a*=t;const n=Math.abs(m);d*=n,g*=n}const b=u===f?-1:1,y=Math.sqrt((d*g-d*p-g*h)/(d*p+g*h)),x=b*y*(s*t[1]/a),w=b*y*(-a*t[0]/s);!function(t,n){if(t===n){var e=n[1];t[1]=n[2],t[2]=e}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3]}(n,n),B(e,i,l),k(e,e,.5),A(o,[x,w],n),B(o,o,e);const F=[(t[0]-x)/s,(t[1]-w)/a],E=q([1,0],F);let v=q(F,[(-t[0]-x)/s,(-t[1]-w)/a]);return!f&&v>0?v-=Q:f&&v<0&&(v+=Q),{center:[o[0],o[1]],theta1:E,deltaTheta:v,rx:s,ry:a,phi:c}}})(),z=(()=>{const t=[0,0],n=[0,0],e=b();return function({center:o,theta1:r,deltaTheta:i,rx:s,ry:a,phi:c}){M(e,c),F(t,s*Math.cos(r),a*Math.sin(r)),A(t,t,e),B(t,t,o),F(n,s*Math.cos(r+i),a*Math.sin(r+i)),A(n,n,e),B(n,n,o);const u=Math.abs(i)>Math.PI;return["A",[t[0],t[1]],s,a,c,u,i>0,[n[0],n[1]]]}})(),j=(()=>{const t=[0,0],n=[0,0],e=[0,0],o=[0,0],r=[0,0],i=[0,0];return function(s,a){switch(s[0]){case"L":P(i,s[1],s[2],a);break;case"C":P(t,s[1],s[2],a),P(n,s[2],s[3],a),P(e,s[3],s[4],a),P(o,t,n,a),P(r,n,e,a),P(i,o,r,a);break;case"Q":P(t,s[1],s[2],a),P(n,s[2],s[3],a),P(i,t,n,a);break;case"A":{const t=Z(s);if(!t){P(i,s[1],s[7],a);break}const{deltaTheta:n,phi:e,theta1:o,rx:r,ry:c,center:u}=t,f=o+a*n;F(i,r*Math.cos(f),c*Math.sin(f)),function(t,n,e,o){var r=n[0]-e[0],i=n[1]-e[1],s=Math.sin(o),a=Math.cos(o);t[0]=r*a-i*s+e[0],t[1]=r*s+i*a+e[1]}(i,i,[0,0],e),B(i,i,u);break}}return[i[0],i[1]]}})(),R=(()=>{const t=y(),n=y();return function(e,o=Math.PI/2){const r=Z(e);if(!r)return[["L",e[1],e[7]]];const{center:i,theta1:s,deltaTheta:a,rx:c,ry:u}=r,f=Math.ceil(Math.abs(a)/o);!function(t,n){t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1]}(t,i),function(t,n,e){var o=n[0],r=n[1],i=n[2],s=n[3],a=n[4],c=n[5],u=Math.sin(e),f=Math.cos(e);t[0]=o*f+i*u,t[1]=r*f+s*u,t[2]=o*-u+i*f,t[3]=r*-u+s*f,t[4]=a,t[5]=c}(t,t,O(e[4])),function(t,n,e){var o=n[0],r=n[1],i=n[2],s=n[3],a=n[4],c=n[5],u=e[0],f=e[1];t[0]=o*u,t[1]=r*u,t[2]=i*f,t[3]=s*f,t[4]=a,t[5]=c}(t,t,[c,u]);const l=[],d=a/f,g=4/3*Math.tan(d/4),h=Math.sin(d),p=Math.cos(d);for(let e=0;e<f;e++){const o=[1,0],r=[1,g],i=[p+g*h,h-g*p],a=[p,h];x(n,s+e*d),w(n,t,n),L(o,o,n),L(r,r,n),L(i,i,n),L(a,a,n),l.push(["C",o,r,i,a])}return l}})();function H(t,n,e,o,r){const i=T(t,n,r),s=T(n,e,r),a=T(e,o,r),c=T(i,s,r),u=T(s,a,r);return T(c,u,r)}function U(t,n,e,o){let r=Math.min(t,o),i=Math.max(t,o);const s=3*(3*n-t-3*e+o),a=6*(t-2*n+e),c=a*a-4*s*(3*(n-t));if(c<0||0===s)return[r,i];const u=Math.sqrt(c),f=(-a-u)/(2*s);if(0<f&&f<1){const s=H(t,n,e,o,f);r=Math.min(r,s),i=Math.max(i,s)}const l=(-a+u)/(2*s);if(0<l&&l<1){const s=H(t,n,e,o,l);r=Math.min(r,s),i=Math.max(i,s)}return[r,i]}function G(t,n,e){let o=Math.min(t,e),r=Math.max(t,e);const i=t-2*n+e;if(0===i)return[o,r];const s=(t-n)/i;if(0<=s&&s<=1){const i=function(t,n,e,o){const r=T(t,n,o),i=T(n,e,o);return T(r,i,o)}(t,n,e,s);o=Math.min(o,i),r=Math.max(r,i)}return[o,r]}function _(t,n,e){const o=(t-n)/(e-n);return 0<=o&&o<=1}function J(t){switch(t[0]){case"L":return{top:Math.min(t[1][1],t[2][1]),right:Math.max(t[1][0],t[2][0]),bottom:Math.max(t[1][1],t[2][1]),left:Math.min(t[1][0],t[2][0])};case"C":{const[n,e]=U(t[1][0],t[2][0],t[3][0],t[4][0]),[o,r]=U(t[1][1],t[2][1],t[3][1],t[4][1]);return{top:o,right:e,bottom:r,left:n}}case"Q":{const[n,e]=G(t[1][0],t[2][0],t[3][0]),[o,r]=G(t[1][1],t[2][1],t[3][1]);return{top:o,right:e,bottom:r,left:n}}case"A":{const n=Z(t);if(!n)return f(d(t[1],0),t[7]);const{theta1:e,deltaTheta:o,phi:r,center:i,rx:s,ry:a}=n;if(0===r||s===a){const n=e+o;let r=f(d(t[1],0),t[7]);return(_(-Math.PI,e,n)||_(Math.PI,e,n))&&(r=f(r,[i[0]-s,i[1]])),(_(-Math.PI/2,e,n)||_(3*Math.PI/2,e,n))&&(r=f(r,[i[0],i[1]-a])),(_(0,e,n)||_(2*Math.PI,e,n))&&(r=f(r,[i[0]+s,i[1]])),(_(Math.PI/2,e,n)||_(5*Math.PI/2,e,n))&&(r=f(r,[i[0],i[1]+a])),function(t,n){return{top:t.top-n,right:t.right+n,bottom:t.bottom+n,left:t.left-n}}(r,1e-11)}const c=R(t,Math.PI/16);let l=null;for(const t of c)l=u(l,J(t));return l||d(t[1],0)}}}function K(t,n){const e=t[1],o=t[2],r=P([0,0],e,o,n);return[["L",e,r],["L",r,o]]}function X(t,n){const e=t[1],o=t[2],r=t[3],i=t[4],s=P([0,0],e,o,n),a=P([0,0],o,r,n),c=P([0,0],r,i,n),u=P([0,0],s,a,n),f=P([0,0],a,c,n),l=P([0,0],u,f,n);return[["C",e,s,u,l],["C",l,f,c,i]]}function Y(t,n){switch(t[0]){case"L":return K(t,n);case"C":return X(t,n);case"Q":return function(t,n){const e=t[1],o=t[2],r=t[3],i=P([0,0],e,o,n),s=P([0,0],o,r,n),a=P([0,0],i,s,n);return[["Q",e,i,a],["Q",a,s,r]]}(t,n);case"A":return function(t,n){const e=Z(t);if(!e)return K(["L",t[1],t[7]],n);const o=e.deltaTheta*n;return[z({...e,deltaTheta:o}),z({...e,theta1:e.theta1+o,deltaTheta:e.deltaTheta-o})]}(t,n)}}function tt([[t,n],[e,o]],[[r,i],[s,a]],c){const u=e-t,f=r-s,l=r-t,d=o-n,g=i-a,h=i-n,p=u*g-d*f;if(Math.abs(p)<c.collinear)return null;const m=(l*g-h*f)/p,b=(u*h-d*l)/p;return-c.param<=m&&m<=1+c.param&&-c.param<=b&&b<=1+c.param?[m,b]:null}function nt(t){const[n,e]=Y(t.seg,.5),o=(t.startParam+t.endParam)/2;return[{seg:n,startParam:t.startParam,endParam:o,boundingBox:J(n)},{seg:e,startParam:o,endParam:t.endParam,boundingBox:J(e)}]}function et(t){switch(t[0]){case"L":return[t[1],t[2]];case"C":return[t[1],t[4]];case"Q":return[t[1],t[3]];case"A":return[t[1],t[7]]}}function ot({seg:t,boundingBox:n},{seg:e,boundingBox:o},r){return"L"===t[0]?"L"===e[0]?function(t,n,e){return!!tt(t,n,e)}([t[1],t[2]],[e[1],e[2]],r):a([t[1],t[2]],o):"L"===e[0]?a([e[1],e[2]],n):c(n,o)}function rt(t,n,e){const o=t[0];if(n[0]!==o)return!1;switch(o){case"L":return N(t[1],n[1],e)&&N(t[2],n[2],e);case"C":return N(t[1],n[1],e)&&N(t[2],n[2],e)&&N(t[3],n[3],e)&&N(t[4],n[4],e);case"Q":return N(t[1],n[1],e)&&N(t[2],n[2],e)&&N(t[3],n[3],e);case"A":return N(t[1],n[1],e)&&Math.abs(t[2]-n[2])<e&&Math.abs(t[3]-n[3])<e&&(Math.abs(t[2]-t[3])<e||Math.abs(t[4]-n[4])<e)&&t[5]===n[5]&&t[6]===n[6]&&N(t[7],n[7],e)}}function it(t,n,e,o){if("L"===t[0]&&"L"===n[0]){const r=[t[1],t[2]],i=[n[1],n[2]];if(function(t,n,e){const o=V([0,0],t[1],t[0]),r=V([0,0],n[1],n[0]);E(o,o),E(r,r);const i=Math.abs(v(o,r));return Math.abs(i-1)<e}(r,i,o.collinear)){const t=function(t,n){const e=V([0,0],t[1],t[0]),o=V([0,0],n[1],n[0]);k(e,e,1/S(e)),k(o,o,1/S(o));const r=[],i=V([0,0],n[0],t[0]),s=v(i,e);s>=0&&s<=1&&r.push([s,0]);const a=v(V([0,0],n[1],t[0]),e);a>=0&&a<=1&&r.push([a,1]);const c=v(k(i,i,-1),o);c>=0&&c<=1&&r.push([0,c]);const u=v(V([0,0],t[1],n[0]),o);return u>=0&&u<=1&&r.push([1,u]),r}(r,i);return t}const s=tt(r,i,o);return s?!e&&(s[0]<o.param||s[0]>1-o.param)&&(s[1]<o.param||s[1]>1-o.param)?[]:[s]:[]}let r=[[{seg:t,startParam:0,endParam:1,boundingBox:J(t)},{seg:n,startParam:0,endParam:1,boundingBox:J(n)}]];const i=[];function s(t){return l(t.boundingBox)<=o.linear||t.endParam-t.startParam<o.param}for(;r.length;){const t=[];for(const[n,e]of r){if(rt(n.seg,e.seg,o.point))continue;const r=s(n),a=s(e);if(r&&a){const t=tt(et(n.seg),et(e.seg),o);t&&i.push([T(n.startParam,n.endParam,t[0]),T(e.startParam,e.endParam,t[1])])}else{const i=r?[n]:nt(n),s=a?[e]:nt(e);for(const n of i)for(const e of s)ot(n,e,o)&&t.push([n,e])}}r=t}return e?i:i.filter((([t,n])=>t>o.param&&t<1-o.param||n>o.param&&n<1-o.param))}const st=Object.hasOwn;function at(t){const n=new WeakMap;return(e,...o)=>{if(n.has(e))return n.get(e);{const r=t(e,...o);return n.set(e,r),r}}}function*ct(t,n){let e=0;for(const o of t)yield n(o,e++)}const ut=8,ft=8,lt={point:1e-6,linear:1e-4,param:1e-8,collinear:64*Number.MIN_VALUE};var dt,gt;function ht(){let t=0;return at((()=>t++))}function pt(t){return n=>({seg:n,parent:t})}function mt(t){return t.outgoingEdges.length}function bt({directionFlag:t,segments:n}){let e,o;const r=n[0];return t?(e=j(r,1),o=j(r,1-lt.param)):(e=j(r,0),o=j(r,lt.param)),Math.atan2(o[1]-e[1],o[0]-e[0])}function Mt(t){const{outgoingEdges:n}=t.incidentVertices[1],e=n.findIndex((n=>n.twin===t));return n[(e+1)%n.length]}t.PathBooleanOperation=void 0,(dt=t.PathBooleanOperation||(t.PathBooleanOperation={}))[dt.Union=0]="Union",dt[dt.Difference=1]="Difference",dt[dt.Intersection=2]="Intersection",dt[dt.Exclusion=3]="Exclusion",dt[dt.Division=4]="Division",dt[dt.Fracture=5]="Fracture",t.FillRule=void 0,(gt=t.FillRule||(t.FillRule={}))[gt.NonZero=0]="NonZero",gt[gt.EvenOdd=1]="EvenOdd";const yt=at((t=>t.incidentEdges.flatMap((t=>{const n=[];for(const e of t.segments)for(let o=0;o<64;o++){const r=o/64,i=t.directionFlag?1-r:r;n.push(j(e,i))}return n}))));function xt(t,n,e){return t>=e==n<e}function wt(t,n,e){return!!xt(t[1],n[1],e[1])&&(o=e[1],r=t[1],i=n[1],s=t[0],a=n[0],(o-r)/(i-r)*(a-s)+s>=e[0]);var o,r,i,s,a}function Ft(t,n){if(t.length<=2)return 0;let e=t[t.length-1],o=0;for(const r of t)wt(e,r,n)&&(o+=r[1]>e[1]?-1:1),e=r;return o}function Bt(t){const n=yt(t);for(let t=0;t<n.length;t++){const e=n[t],o=n[(t+1)%n.length],r=n[(t+2)%n.length],i=[(e[0]+o[0]+r[0])/3,(e[1]+o[1]+r[1])/3],s=Ft(n,i);if(0!==s)return{winding:s,point:i}}}function kt(t,n){return xt(t.top,t.bottom,n[1])&&t.right>=n[0]}function Et(t,n){const e=J(t);if(!kt(e,n))return 0;let o=[{boundingBox:e,seg:t}],r=0;for(;o.length>0;){const t=[];for(const{boundingBox:e,seg:i}of o)if(l(e)<lt.linear)wt($(i),D(i),n)&&r++;else{const e=Y(i,.5),o=J(e[0]);kt(o,n)&&t.push({boundingBox:o,seg:e[0]});const r=J(e[1]);kt(r,n)&&t.push({boundingBox:r,seg:e[1]})}o=t}return r}function vt(t,n){const e=$(t.edges[0].segments[0]);for(const t of n.vertices){if(t===n.outerFace)continue;let o=0;for(const n of t.incidentEdges)for(const t of n.segments)o+=Et(t,e);if(o%2==1)return t}return null}function Pt(n,e){switch(e){case t.FillRule.NonZero:return 0===n?0:1;case t.FillRule.EvenOdd:return n%2==0?0:1}}function*At(t){function n(n){return t.has(n.incidentVertex)===t.has(n.twin.incidentVertex)}const e=new WeakMap;for(const n of t){let t=n.incidentEdges[n.incidentEdges.length-1];for(const o of n.incidentEdges)e.set(t,o),t=o}const o=new WeakSet;for(const r of t)for(const t of r.incidentEdges){if(n(t)||o.has(t))continue;let r=t;do{for(r.directionFlag?yield*ct(r.segments,W):yield*r.segments,o.add(r),r=e.get(r);n(r);)r=e.get(r.twin)}while(r!==t)}}const Lt={[t.PathBooleanOperation.Union]:({flag:t})=>t>0,[t.PathBooleanOperation.Difference]:({flag:t})=>1===t,[t.PathBooleanOperation.Intersection]:({flag:t})=>3===t,[t.PathBooleanOperation.Exclusion]:({flag:t})=>1===t||2===t,[t.PathBooleanOperation.Division]:({flag:t})=>!(1&~t),[t.PathBooleanOperation.Fracture]:({flag:t})=>t>0};function Ct(t,n){return[2*t[0]-n[0],2*t[1]-n[1]]}function*It(t){let n=null,e=null,o=null;function r(){throw new Error("Bad SVG path data sequence.")}for(const i of function*(t){let n=[0,0],e=n;for(const o of t)switch(o[0]){case"M":yield o,n=e=o[1];break;case"L":case"T":yield o,n=o[1];break;case"C":yield o,n=o[3];break;case"S":case"Q":yield o,n=o[2];break;case"A":yield o,n=o[6];break;case"Z":case"z":n=e,yield["Z"];break;case"H":n=[o[1],n[1]],yield["L",n];break;case"V":n=[n[0],o[1]],yield["L",n];break;case"m":n=e=[n[0]+o[1],n[1]+o[2]],yield["M",n];break;case"l":n=[n[0]+o[1],n[1]+o[2]],yield["L",n];break;case"h":n=[n[0]+o[1],n[1]],yield["L",n];break;case"v":n=[n[0],n[1]+o[1]],yield["L",n];break;case"c":yield["C",[n[0]+o[1],n[1]+o[2]],[n[0]+o[3],n[1]+o[4]],n=[n[0]+o[5],n[1]+o[6]]];break;case"s":yield["S",[n[0]+o[1],n[1]+o[2]],n=[n[0]+o[3],n[1]+o[4]]];break;case"q":yield["Q",[n[0]+o[1],n[1]+o[2]],n=[n[0]+o[3],n[1]+o[4]]];break;case"t":yield["T",n=[n[0]+o[1],n[1]+o[2]]];break;case"a":yield["A",o[1],o[2],o[3],o[4],o[5],n=[n[0]+o[6],n[1]+o[7]]]}}(t))switch(i[0]){case"M":e=n=i[1],o=null;break;case"L":e||r(),yield["L",e,i[1]],e=i[1],o=null;break;case"C":e||r(),yield["C",e,i[1],i[2],i[3]],e=i[3],o=i[2];break;case"S":e||r(),o||r(),yield["C",e,Ct(e,o),i[1],i[2]],e=i[2],o=i[1];break;case"Q":e||r(),yield["Q",e,i[1],i[2]],e=i[2],o=i[1];break;case"T":e||r(),o||r(),o=Ct(e,o),yield["Q",e,o,i[1]],e=i[1];break;case"A":e||r(),yield["A",e,i[1],i[2],i[3],i[4],i[5],i[6]],e=i[6],o=null;break;case"Z":case"z":e||r(),n||r(),yield["L",e,n],e=n,o=null}}function*Vt(t,n=1e-4){let e=null;for(const o of t)switch(e&&N(o[1],e,n)||(yield["M",o[1]]),o[0]){case"L":yield["L",e=o[2]];break;case"C":yield["C",o[2],o[3],e=o[4]];break;case"Q":yield["Q",o[2],e=o[3]];break;case"A":yield["A",o[2],o[3],o[4],o[5],o[6],e=o[7]]}}const St=Symbol();function*Qt(t){const n=/(-?\d*(?:\d\.|\.\d|\d)\d*(?:[eE][+\-]?\d+)?)/y,e=/([MLCSQTAZHVmlhvcsqtaz])/y,o=/([01])/y,r=/\s*,?\s*/y;let i=0;function s(){r.lastIndex=i,null!==r.exec(t)&&(i=r.lastIndex)}let a="M",c=-1;function u(){if(s(),i>t.length-1)return St;e.lastIndex=i;const n=e.exec(t);if(!n)switch(a){case"M":return"L";case"m":return"l";case"Z":case"z":if(i===c)throw new Error(`Invalid path data. Invalid syntax at index ${i}.`);return c=i,a;default:return a}return i=e.lastIndex,n[1]}function f(){s(),n.lastIndex=i;const e=n.exec(t);if(!e)throw new Error(`Invalid path data. Expected a number at index ${i}.`);return i=n.lastIndex,Number(e[1])}function l(){s(),o.lastIndex=i;const n=o.exec(t);if(!n)throw new Error(`Invalid path data. Expected a flag at index ${i}.`);return i=o.lastIndex,"1"===n[1]}for(;;)switch(u()){case"M":yield[a="M",[f(),f()]];break;case"L":yield[a="L",[f(),f()]];break;case"C":yield[a="C",[f(),f()],[f(),f()],[f(),f()]];break;case"S":yield[a="S",[f(),f()],[f(),f()]];break;case"Q":yield[a="Q",[f(),f()],[f(),f()]];break;case"T":yield[a="T",[f(),f()]];break;case"A":yield[a="A",f(),f(),f(),l(),l(),[f(),f()]];break;case"Z":case"z":yield[a="Z"];break;case"H":yield[a="H",f()];break;case"V":yield[a="V",f()];break;case"m":yield[a="m",f(),f()];break;case"l":yield[a="l",f(),f()];break;case"h":yield[a="h",f()];break;case"v":yield[a="v",f()];break;case"c":yield[a="c",f(),f(),f(),f(),f(),f()];break;case"s":yield[a="s",f(),f(),f(),f()];break;case"q":yield[a="q",f(),f(),f(),f()];break;case"t":yield[a="t",f(),f()];break;case"a":yield[a="a",f(),f(),f(),l(),l(),f(),f()];break;case St:return}}t.arcSegmentToCubics=R,t.commandsFromPathData=Qt,t.pathBoolean=function(n,e,o,r,i){const s=[...ct(n,pt(1)),...ct(o,pt(2))];!function(t){for(let n=0;n<t.length;n++){const e=t[n];if("C"!==e.seg[0])continue;const o=p(e.seg);if(!o)continue;o[0]>o[1]&&o.reverse();const[r,i]=o;if(Math.abs(r-i)<lt.param){const[o,i]=X(e.seg,r);t[n]={seg:o,parent:e.parent},t.push({seg:i,parent:e.parent})}else{const[o,s]=X(e.seg,r),[a,c]=X(s,(i-r)/(1-r));t[n]={seg:o,parent:e.parent},t.push({seg:a,parent:e.parent},{seg:c,parent:e.parent})}}}(s);const{edges:a,totalBoundingBox:c}=function(t){const n=t.map((t=>({...t,boundingBox:J(t.seg)}))),e=n.reduce(((t,{boundingBox:n})=>u(t,n)),null);if(!e)return{edges:[],totalBoundingBox:null};const o=new g(e,ut),r={};function i(t,n){st(r,t)||(r[t]=[]),r[t].push(n)}for(let e=0;e<n.length;e++){const r=n[e],s=o.find(r.boundingBox);for(const n of s){const o=t[n],s=it(r.seg,o.seg,!0,lt);for(const[t,o]of s)i(e,t),i(n,o)}o.insert(r.boundingBox,e)}const s=[];for(let t=0;t<n.length;t++){const e=n[t];if(!st(r,t)){s.push(e);continue}const o=r[t];o.sort();let i=e.seg,a=0;for(let t=0;t<o.length;t++){const n=o[t];if(n>1-lt.param)break;const r=(n-a)/(1-a);if(a=n,r<lt.param)continue;if(r>1-lt.param)continue;const[c,u]=Y(i,r);s.push({seg:c,boundingBox:J(c),parent:e.parent}),i=u}s.push({seg:i,boundingBox:J(i),parent:e.parent})}return{edges:s,totalBoundingBox:e}}(s);if(!c)return[];const f=function(t,n){const e=new g(n,ft),o=[];function r(t){const n=d(t,lt.point),r=e.find(n);if(r.size)return function(t){return t.values().next().value}(r);{const r={point:t,outgoingEdges:[]};return e.insert(n,r),o.push(r),r}}const i=ht(),s={};return{edges:t.flatMap((t=>{const n=r($(t.seg)),e=r(D(t.seg));if(n===e)switch(t.seg[0]){case"L":return[];case"C":if(N(t.seg[1],t.seg[2],lt.point)&&N(t.seg[3],t.seg[4],lt.point))return[];break;case"Q":if(N(t.seg[1],t.seg[2],lt.point))return[];break;case"A":if(!1===t.seg[5])return[]}const o=`${i(n)}:${i(e)}`;if(st(s,o)){const n=s[o].find((n=>rt(n[0].seg,t.seg,lt.point)));if(n)return n[1].parent|=t.parent,n[2].parent|=t.parent,[]}const a=`${i(e)}:${i(n)}`;if(st(s,a)){const n=W(t.seg),e=s[a].find((t=>rt(t[0].seg,n,lt.point)));if(e)return e[0].parent===t.parent||(e[1].parent|=t.parent,e[1].directionFlagA=1===t.parent,e[1].directionFlagB=2===t.parent,e[2].parent|=t.parent,e[2].directionFlagA=1===t.parent,e[2].directionFlagB=2===t.parent),[]}const c={...t,incidentVertices:[n,e],directionFlag:!1,directionFlagA:!1,directionFlagB:!1,twin:null},u={...t,incidentVertices:[e,n],directionFlag:!0,directionFlagA:1===t.parent,directionFlagB:2===t.parent,twin:c};return c.twin=u,n.outgoingEdges.push(c),e.outgoingEdges.push(u),st(s,o)?s[o].push([t,c,u]):s[o]=[[t,c,u]],[c,u]})),vertices:o}}(a,c),l=function({vertices:t}){const n=[],e=[],o=at((t=>{const n={outgoingEdges:[]};return e.push(n),n})),r=ht(),i={},s=new WeakSet;for(const e of t){if(2===mt(e))continue;const t=o(e);for(const a of e.outgoingEdges){const e=[];let c=a;for(;c.parent===a.parent&&c.directionFlag===a.directionFlag&&c.directionFlagA===a.directionFlagA&&c.directionFlagB===a.directionFlagB&&2===mt(c.incidentVertices[1]);){e.push(c.seg),s.add(c.incidentVertices[1]);const[t,n]=c.incidentVertices[1].outgoingEdges;c=t.twin===c?n:t}e.push(c.seg);const u=o(c.incidentVertices[1]),f=`${r(a)}-${r(c)}`,l=i[`${r(c.twin)}-${r(a.twin)}`]??null,d={segments:e,parent:a.parent,incidentVertices:[t,u],directionFlag:a.directionFlag,directionFlagA:a.directionFlagA,directionFlagB:a.directionFlagB,twin:l};l&&(l.twin=d),i[f]=d,t.outgoingEdges.push(d),n.push(d)}}const a=[];for(const n of t){if(2!==mt(n)||s.has(n))continue;let t=n.outgoingEdges[0];const e={segments:[],parent:t.parent,directionFlag:t.directionFlag,directionFlagA:t.directionFlagA,directionFlagB:t.directionFlagB};do{e.segments.push(t.seg),s.add(t.incidentVertices[0]);const[n,o]=t.incidentVertices[1].outgoingEdges;t=n.twin===t?o:n}while(t.incidentVertices[0]!==n);a.push(e)}return{edges:n,vertices:e,cycles:a}}(f);!function(t){function n(n){const e=new WeakSet,o=new WeakMap;function r(t,i,s){if(o.has(t))return o.get(t);o.set(t,s);let a=1/0;for(const e of t.outgoingEdges)e.parent&n&&e!==i&&(a=Math.min(a,r(e.incidentVertices[1],e.twin,s+1)));return a<=s&&e.add(t),a}for(const e of t.edges)e.parent&n&&r(e.incidentVertices[0],null,0);return e}const e=n(1),o=n(2);function r(t){return!(1&~t.parent)&&e.has(t.incidentVertices[0])&&e.has(t.incidentVertices[1])||!(2&~t.parent)&&o.has(t.incidentVertices[0])&&o.has(t.incidentVertices[1])}t.vertices=t.vertices.filter((function(t){return e.has(t)||o.has(t)}));for(const n of t.vertices)n.outgoingEdges=n.outgoingEdges.filter(r);t.edges=t.edges.filter(r)}(l),function({vertices:t}){const n=at(bt);for(const e of t)mt(e)>2&&e.outgoingEdges.sort(((t,e)=>n(t)-n(e)))}(l);const h=function(t){let n=[];function e(t,n){let o=!1;for(const r of t){const t=vt(n,r.component);if(t){if(r.outgoingEdges.has(t)){const o=r.outgoingEdges.get(t);r.outgoingEdges.set(t,e(o,n))}else r.outgoingEdges.set(t,[{component:n,outgoingEdges:new Map}]);o=!0;break}}if(o)return t;{const e={component:n,outgoingEdges:new Map},o=[e];for(const r of t){const t=vt(r.component,n);t?e.outgoingEdges.has(t)?e.outgoingEdges.get(t).push(r):e.outgoingEdges.set(t,[r]):o.push(r)}return o}}for(const o of t)n=e(n,o);return n}(function({edges:t,cycles:n}){const e=[],o=new WeakMap;for(const n of t){if(o.has(n))continue;const t={incidentEdges:[],flag:0};let r=n;do{const n=o.get(r.twin)??null,e={segments:r.segments,parent:r.parent,incidentVertex:t,directionFlag:r.directionFlag,directionFlagA:r.directionFlagA,directionFlagB:r.directionFlagB,twin:n};n&&(n.twin=e),o.set(r,e),t.incidentEdges.push(e),r=Mt(r)}while(r!==n);e.push(t)}for(const t of n){const n={incidentEdges:[],flag:0},o={segments:t.segments,parent:t.parent,incidentVertex:n,directionFlag:t.directionFlag,directionFlagA:t.directionFlagA,directionFlagB:t.directionFlagB,twin:null},r={incidentEdges:[],flag:0},i={segments:[...t.segments].reverse(),parent:t.parent,incidentVertex:r,directionFlag:!t.directionFlag,directionFlagA:!t.directionFlagA,directionFlagB:!t.directionFlagB,twin:o};o.twin=i,n.incidentEdges.push(o),r.incidentEdges.push(i),e.push(n,r)}const r=[],i=new WeakSet,s=new WeakSet;for(const t of e){if(i.has(t))continue;const n=[],e=[],o=t=>{i.has(t)||n.push(t),i.add(t);for(const n of t.incidentEdges){if(s.has(n))continue;const{twin:t}=n;e.push(n,t),s.add(n),s.add(t),o(t.incidentVertex)}};o(t);const a=n.find((t=>Bt(t).winding<0));r.push({vertices:n,edges:e,outerFace:a})}return r}(l));!function(t,n,e){function o(t,r,i){const s=new WeakSet;!function r(i,a,c){if(s.has(i))return;s.add(i);const u=Pt(a,n),f=Pt(c,e);i.flag=u|f<<1;for(const t of i.incidentEdges){const n=t.twin;let e=a;1&t.parent&&(e+=t.directionFlagA?-1:1);let o=c;2&t.parent&&(o+=t.directionFlagB?-1:1),r(n.incidentVertex,e,o)}if(t.outgoingEdges.has(i)){const n=t.outgoingEdges.get(i);for(const t of n)o(t,a,c)}}(t.component.outerFace,r,i)}for(const n of t)o(n,0,0)}(h,e,r);const m=Lt[i];switch(i){case t.PathBooleanOperation.Division:case t.PathBooleanOperation.Fracture:return function(t,n){const e=[];function o(t){for(const o of t.component.vertices){if(!n(o)||o===t.component.outerFace)continue;const r=[];for(const t of o.incidentEdges)t.directionFlag?r.push(...t.segments.map(W)):r.push(...t.segments);if(t.outgoingEdges.has(o))for(const n of t.outgoingEdges.get(o)){const{outerFace:t}=n.component;for(const n of t.incidentEdges)n.directionFlag?r.push(...n.segments.map(W)):r.push(...n.segments)}e.push(r)}for(const n of t.outgoingEdges.values())for(const t of n)o(t)}for(const n of t)o(n);return e}(h,m);default:{const t=new Set(function*(t,n){function*e(t){for(const e of t.component.vertices)n(e)&&(yield e);for(const n of t.outgoingEdges.values())for(const t of n)yield*e(t)}for(const n of t)yield*e(n)}(h,m));return[[...At(t)]]}}},t.pathCubicSegmentSelfIntersection=p,t.pathFromCommands=It,t.pathFromPathData=function(t){return[...It(Qt(t))]},t.pathSegmentBoundingBox=J,t.pathSegmentIntersection=it,t.pathToCommands=Vt,t.pathToPathData=function(t,n=1e-4){function e(t){return"string"==typeof t?t:function(t){return"number"==typeof t}(t)?t.toFixed(12):function(t){return"boolean"==typeof t}(t)?t?"1":"0":t.map((t=>t.toFixed(12))).join(",")}return[...ct(Vt(t,n),(t=>t.map(e).join(" ")))].join(" ")},t.samplePathSegmentAt=j},"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).PathBool={});
